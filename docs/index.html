<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Asobiba</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
    <style>
      .hidden {
        display: none;
      }

      [role="alertdialog"],
      [role="dialog"] {
        box-sizing: border-box;
        padding: 15px;
        border: 1px solid #000;
        background-color: #fff;
        min-height: 100vh;
      }

      @media screen and (min-width: 640px) {
        [role="alertdialog"],
        [role="dialog"] {
          position: absolute;
          top: 2rem;
          left: 50vw;  /* move to the middle of the screen (assumes relative parent is the body/viewport) */
          transform: translateX(-50%);  /* move backwards 50% of this element's width */
          min-width: calc(640px - (15px * 2));  /* == breakpoint - left+right margin */
          min-height: auto;
          box-shadow: 0 19px 38px rgba(0, 0, 0, 0.12), 0 15px 12px rgba(0, 0, 0, 0.22);
        }
      }

      .dialog_label {
        text-align: center;
      }

      .dialog_form {
        margin: 15px;
      }

      .dialog_form .label_text {
        box-sizing: border-box;
        padding-right: 0.5em;
        display: inline-block;
        font-size: 16px;
        font-weight: bold;
        width: 30%;
        text-align: right;
      }

      .dialog_form .label_info {
        box-sizing: border-box;
        padding-right: 0.5em;
        font-size: 12px;
        width: 30%;
        text-align: right;
        display: inline-block;
      }

      .dialog_form_item {
        margin: 10px 0;
        font-size: 0;
      }

      .dialog_form_item .wide_input {
        box-sizing: border-box;
        max-width: 70%;
        width: 27em;
      }

      .dialog_form_item .city_input {
        box-sizing: border-box;
        max-width: 70%;
        width: 17em;
      }

      .dialog_form_item .state_input {
        box-sizing: border-box;
        max-width: 70%;
        width: 15em;
      }

      .dialog_form_item .zip_input {
        box-sizing: border-box;
        max-width: 70%;
        width: 9em;
      }

      .dialog_form_actions {
        text-align: right;
        padding: 0 20px 20px;
      }

      .dialog_close_button {
        float: right;
        position: absolute;
        top: 10px;
        left: 92%;
        height: 25px;
      }

      .dialog_close_button img {
        border: 0;
      }

      .dialog_desc {
        padding: 10px 20px;
      }

      /* native <dialog> element uses the ::backdrop pseudo-element */

      /* dialog::backdrop, */
      .dialog-backdrop {
        display: none;
        position: fixed;
        overflow-y: auto;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
      }

      @media screen and (min-width: 640px) {
        .dialog-backdrop {
          background: rgba(0, 0, 0, 0.3);
        }
      }

      .dialog-backdrop.active {
        display: block;
      }

      .no-scroll {
        overflow-y: auto !important;
      }

      /* this is added to the body when a dialog is open */
      .has-dialog {
        overflow: hidden;
      }

      /* styling for alert-dialog example */
      .notes {
        display: block;
        font-size: 1rem;
        line-height: 1.3;
        min-width: 400px;
        max-width: 100%;
        width: 33%;
      }

      .toast {
        background-color: rgba(0, 0, 0, 0.9);
        color: #fff;
        padding: 1rem;
        border: none;
        border-radius: 0.25rem;
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16), 0 3px 6px rgba(0, 0, 0, 0.23);
        position: fixed;
        top: 1rem;
        right: 1rem;
        transform: translateY(-150%);
        transition: transform 225ms cubic-bezier(0.4, 0, 0.2, 1);
      }

      .toast.active {
        transform: translateY(0);
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.19/lodash.min.js"></script>

    <script>
      var aria = aria || {};

      aria.consoleLog = (str)=> {
        const consoleElm = document.getElementById('console');
        consoleElm.value = consoleElm.value + '\n' + str;
      }
    </script>
  </head>
  <body>
    <h1>Asobiba</h1>

    <textarea id="console" class="notes">ここにデバッグ内容が書かれます。</textarea>

    <h2>ブラウザバック時にキャッシュ利用しているか否かの制御に関する実験</h2>

    <button onclick="increaseBrowserBackValue()">browserBackValue+1</button>

    <p>参考:<a href="https://qiita.com/shibe23/items/79f950061457ff1a7687">https://qiita.com/shibe23/items/79f950061457ff1a7687</a></p>

    <script>
      window.aria.browserBackValue = 0
      window.addEventListener("pageshow", function(event){
        if (event.persisted) {
          aria.consoleLog('おや、キャッシュを利用してるみたいですよ！')
        }
      });

      function increaseBrowserBackValue () {
        window.aria.browserBackValue++
        aria.consoleLog('browserBackValue:' + window.aria.browserBackValue)
      }
    </script>

    <h2>ページ内リンクにおけるViceOverのカーソルに移動に関しての実験</h2>

    <p>参考:https://accessphilia.com/ja/blog/vo-link-within-page-2</p>

    <p>この環境内ではカーソルが移動しない現象を再現できないかもしれない…？</p>

    <a href="#maintarget">mainへ遷移</a>

    <p>ダミー</p>
    <p>ダミー</p>
    <p>ダミー</p>

    <main id="maintarget" tabindex="-1">
      <div>
        <div>
          <div>
            <div style="display: flex;">
              <div>
                <i style="display:inline-block">一つ目はdivに囲まれたi要素です</i>
                タイトル想定です
              </div>
            </div>
          </div>
      ここがメインです。
    </main>

    <h2>ViceOverのカーソルに移動に関しての実験</h2>

    <p>コンボボックスコンポーネントを想定して、入力要素の次のフォーカス位置を選択肢の先頭にもっていきたかったが、VoiceOverではfocusもfocusinもカーソル移動時に発火しなかった。</p>

    <div id="menu" class="dialogbox" style="padding: 1em; border: solid #000 1px;">
      <span id="teleporterMenu1" class="teleporter" aria-controls="input" tabindex="0">tele</span>
      <ul>
        <li>
          <a href="#">メニュー1</a>
        </li>
        <li>
          <a href="#">メニュー2</a>
        </li>
        <li>
          <a href="#">メニュー3</a>
        </li>
      </ul>
      <span id="teleporterMenu2" class="teleporter" aria-controls="input" tabindex="0">tele</span>
    </div>

    <ul>
      <li>
        <a href="#">ダミーリンク1</a>
      </li>
      <li>
        <a href="#">ダミーリンク2</a>
      </li>
      <li>
        <a href="#">ダミーリンク3</a>
      </li>
    </ul>

    <span id="teleporterInput1" class="teleporter teleporter--toLast" aria-controls="menu" tabindex="0">tele</span>
    <input id="input" aria-controls="menu" type="text">
    <span id="teleporterInput2" class="teleporter teleporter--toFirst" aria-controls="menu" tabindex="0">tele</span>

    <script>
      // タブキーでフォーカス可能な要素のみ
      const tabFocusableSelector = 'a[href]:not([disabled]), button:not([disabled]), input:not([disabled]), textarea:not([disabled]), [tabindex="0"]:not(.teleporter)'

      const teleporters = document.querySelectorAll('.teleporter');
      teleporters.forEach((teleporter)=>{
        const isToFirst = teleporter.classList.contains('teleporter--toFirst');
        const isToLast = teleporter.classList.contains('teleporter--toLast');

        teleporter.addEventListener('focusin', ()=>{
          const target = document.getElementById(teleporter.getAttribute('aria-controls'));

          if (!isToFirst && !isToLast) {
            target && target.focus()

          } else {
            childlen = target && target.querySelectorAll(tabFocusableSelector);
            let target2
            if (childlen)
              target2 = isToFirst ? childlen[0] : _.last(childlen);
            target2 && target2.focus()
          }
              
          aria.consoleLog('フォーカスしました：' + teleporter.id)
          aria.consoleLog(teleporter.getAttribute('aria-controls') + ' に遷移します')
          isToFirst && aria.consoleLog('先頭です')
          isToLast && aria.consoleLog('末尾です')
        })
      })
    </script>

    <h2>ViceOverの自前ダイアログのアクセシビリティに関しての実験</h2>

    <p>
      参考: https://www.w3.org/TR/wai-aria-practices-1.1/examples/dialog-modal/alertdialog.html
    </p>

    <label for="notes">
      Notes
    </label>
    <textarea class="notes"
              name="notes"
              id="notes"
              rows="7">
      This is an example text box, which unsurprisingly contains text. The user is given the option to save this text - which triggers a basic alert - or to discard the text - which triggers an alert dialog that prompts the user for confirmation.
    </textarea>
    <button type="button"
            aria-controls="notes"
            id="notes_save">
      Save
    </button>
    <button type="button"
            aria-controls="notes"
            id="notes_discard"
            onclick="openAlertDialog('alert_dialog', this)">
      Discard
    </button>
    <button type="button"
            aria-controls="notes"
            id="notes_discard2"
            onclick="openAlertDialog('alert_dialog', this, 'dialog_desc')">
      Discard2
    </button>

    <div role="alert"
         id="alert_toast"
         class="toast hidden">
      Nothing to discard.
    </div>
    <div class="dialog-backdrop no-scroll">
      <div id="alert_dialog"
           role="alertdialog"
           aria-modal="true"
           aria-labelledby="dialog_label"
           aria-describedby="dialog_desc"
           class="hidden">
        <h2 id="dialog_label" class="dialog_label">
          Confirmation
        </h2>
        <div tabindex="-1" id="dialog_desc" class="dialog_desc">
          <p>
            Are you sure you want to discard all of your notes?
          </p>
        </div>
        <div class="dialog_form_actions">
          <button type="button" onclick="closeDialog(this)">
            No
          </button>
          <button type="button"
                  aria-controls="notes"
                  id="notes_confirm"
                  onclick="discardInput(this)">
            Yes
          </button>
        </div>
      </div>
    </div>
  </body>

  <script>
    /**
     * Utils ---------------------------------------------
     */

    /**
     * @namespace aria
     */

    var aria = aria || {};

    /**
     * @desc
     *  Key code constants
     */
    aria.KeyCode = {
      BACKSPACE: 8,
      TAB: 9,
      RETURN: 13,
      ESC: 27,
      SPACE: 32,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      END: 35,
      HOME: 36,
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
      DELETE: 46
    };

    aria.Utils = aria.Utils || {};

    // Polyfill src https://developer.mozilla.org/en-US/docs/Web/API/Element/matches
    aria.Utils.matches = function (element, selector) {
      if (!Element.prototype.matches) {
        Element.prototype.matches =
          Element.prototype.matchesSelector ||
          Element.prototype.mozMatchesSelector ||
          Element.prototype.msMatchesSelector ||
          Element.prototype.oMatchesSelector ||
          Element.prototype.webkitMatchesSelector ||
          function (s) {
            var matches = element.parentNode.querySelectorAll(s);
            var i = matches.length;
            while (--i >= 0 && matches.item(i) !== this) {}
            return i > -1;
          };
      }

      return element.matches(selector);
    };

    aria.Utils.remove = function (item) {
      if (item.remove && typeof item.remove === 'function') {
        return item.remove();
      }
      if (item.parentNode &&
          item.parentNode.removeChild &&
          typeof item.parentNode.removeChild === 'function') {
        return item.parentNode.removeChild(item);
      }
      return false;
    };

    aria.Utils.isFocusable = function (element) {
      if (element.tabIndex > 0 || (element.tabIndex === 0 && element.getAttribute('tabIndex') !== null)) {
        return true;
      }

      if (element.disabled) {
        return false;
      }

      switch (element.nodeName) {
        case 'A':
          return !!element.href && element.rel != 'ignore';
        case 'INPUT':
          return element.type != 'hidden' && element.type != 'file';
        case 'BUTTON':
        case 'SELECT':
        case 'TEXTAREA':
          return true;
        default:
          return false;
      }
    };

    aria.Utils.getAncestorBySelector = function (element, selector) {
      if (!aria.Utils.matches(element, selector + ' ' + element.tagName)) {
        // Element is not inside an element that matches selector
        return null;
      }

      // Move up the DOM tree until a parent matching the selector is found
      var currentNode = element;
      var ancestor = null;
      while (ancestor === null) {
        if (aria.Utils.matches(currentNode.parentNode, selector)) {
          ancestor = currentNode.parentNode;
        }
        else {
          currentNode = currentNode.parentNode;
        }
      }

      return ancestor;
    };

    aria.Utils.hasClass = function (element, className) {
      return (new RegExp('(\\s|^)' + className + '(\\s|$)')).test(element.className);
    };

    aria.Utils.addClass = function (element, className) {
      if (!aria.Utils.hasClass(element, className)) {
        element.className += ' ' + className;
      }
    };

    aria.Utils.removeClass = function (element, className) {
      var classRegex = new RegExp('(\\s|^)' + className + '(\\s|$)');
      element.className = element.className.replace(classRegex, ' ').trim();
    };

    aria.Utils.bindMethods = function (object /* , ...methodNames */) {
      var methodNames = Array.prototype.slice.call(arguments, 1);
      methodNames.forEach(function (method) {
        object[method] = object[method].bind(object);
      });
    };

    /**
     * alertdialog ---------------------------------------------
     */
    
    var aria = aria || {};

    aria.Utils = aria.Utils || {};

    aria.Utils.disableCtrl = function (ctrl) {
      ctrl.setAttribute('disabled', true);
    };

    aria.Utils.enableCtrl = function (ctrl) {
      ctrl.removeAttribute('disabled');
    };

    aria.Utils.triggerAlert = function (alertEl, content) {
      return new Promise(function (resolve, reject) {
        try {
          alertEl.textContent = content || null;
          alertEl.classList.remove('hidden');
          alertEl.addEventListener('transitionend', function (e) {
            if (!this.classList.contains('active')) {
              this.classList.add('hidden');
            }
          }, true);
          setTimeout(function () {
            alertEl.classList.add('active');
          }, 1);
          setTimeout(function () {
            alertEl.classList.remove('active');
            resolve();
          }, 3000);
        }
        catch (err) {
          reject(err);
        }
      });
    };

    aria.Notes = function Notes (notesId, saveId, discardId, localStorageKey) {
      this.notesInput = document.getElementById(notesId);
      this.saveBtn = document.getElementById(saveId);
      this.discardBtn = document.getElementById(discardId);
      this.localStorageKey = localStorageKey || 'alertdialog-notes';
      this.initialized = false;

      Object.defineProperty(this, 'controls', {
        get: function () {
          return document.querySelectorAll('[aria-controls=' + this.notesInput.id + ']');
        }
      });
      Object.defineProperty(this, 'hasContent', {
        get: function () {
          return this.notesInput.value.length > 0;
        }
      });
      Object.defineProperty(this, 'savedValue', {
        get: function () {
          return JSON.parse(localStorage.getItem(this.localStorageKey));
        },
        set: function (val) {
          this.save(val);
        }
      });
      Object.defineProperty(this, 'isCurrent', {
        get: function () {
          return this.notesInput.value === this.savedValue;
        }
      });
      Object.defineProperty(this, 'oninput', {
        get: function () {
          return this.notesInput.oninput;
        },
        set: function (fn) {
          if (typeof fn !== 'function') {
            throw new TypeError('oninput must be a function');
          }
          this.notesInput.addEventListener('input', fn);
        }
      });

      if (this.saveBtn && this.discardBtn) {
        this.init();
      }
    };

    aria.Notes.prototype.save = function (val) {
      if (this.alert && !this.isCurrent) {
        aria.Utils.triggerAlert(this.alert, 'Saved');
      }
      localStorage.setItem(this.localStorageKey, JSON.stringify(val || this.notesInput.value));
      aria.Utils.disableCtrl(this.saveBtn);
    };

    aria.Notes.prototype.loadSaved = function () {
      if (this.savedValue) {
        this.notesInput.value = this.savedValue;
      }
    };

    aria.Notes.prototype.discard = function () {
      localStorage.clear();
      this.notesInput.value = '';
      this.toggleCtrls();
    };

    aria.Notes.prototype.disableCtrls = function () {
      this.controls.forEach(aria.Utils.disableCtrl);
    };

    aria.Notes.prototype.enableCtrls = function () {
      this.controls.forEach(aria.Utils.enableCtrl);
    };

    aria.Notes.prototype.toggleCtrls = function () {
      if (this.hasContent) {
        this.enableCtrls();
      }
      else {
        this.disableCtrls();
      }
    };

    aria.Notes.prototype.toggleCurrent = function () {
      if (!this.isCurrent) {
        this.notesInput.classList.remove('can-save');
        aria.Utils.enableCtrl(this.saveBtn);
      }
      else {
        this.notesInput.classList.add('can-save');
        aria.Utils.disableCtrl(this.saveBtn);
      }
    };

    aria.Notes.prototype.keydownHandler = function (e) {
      var mod = (navigator.userAgent.includes('Mac')) ? e.metaKey : e.ctrlKey;
      if (e.key === 's' & mod) {
        e.preventDefault();
        this.save();
      }
    };

    aria.Notes.prototype.init = function () {
      if (!this.initialized) {
        this.loadSaved();
        this.toggleCurrent();
        this.saveBtn.addEventListener('click', this.save.bind(this, undefined));
        this.discardBtn.addEventListener('click', this.discard.bind(this));
        this.notesInput.addEventListener('input', this.toggleCtrls.bind(this));
        this.notesInput.addEventListener('input', this.toggleCurrent.bind(this));
        this.notesInput.addEventListener('keydown', this.keydownHandler.bind(this));
        this.initialized = true;
      }
    };

    /** initialization */
    document.addEventListener('DOMContentLoaded', function initAlertDialog () {
      var notes = new aria.Notes('notes', 'notes_save', 'notes_confirm');
      notes.alert = document.getElementById('alert_toast');

      window.discardInput = function (closeBtn) {
        notes.discard.call(notes);
        closeDialog(closeBtn);
      };

      window.openAlertDialog = function (dialogId, triggerBtn, focusFirst) {
        var target = document.getElementById(triggerBtn.getAttribute('aria-controls'));
        var dialog = document.getElementById(dialogId);
        var desc = document.getElementById(dialog.getAttribute('aria-describedby'));
        var wordCount = document.getElementById('word_count');
        if (!wordCount) {
          wordCount = document.createElement('p');
          wordCount.id = 'word_count';
          desc.appendChild(wordCount);
        }
        var count = target.value.split(/\s/).length;
        var frag = (count > 1) ? 'words' : 'word';
        wordCount.textContent =  count + ' ' + frag + ' will be deleted.';
        openDialog(dialogId, target, focusFirst);
      };
    });

    /**
     * dialog ---------------------------------------------
     */

    /*
    *   This content is licensed according to the W3C Software License at
    *   https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
    */

    var aria = aria || {};

    aria.Utils = aria.Utils || {};

    (function () {
      /*
      * When util functions move focus around, set this true so the focus listener
      * can ignore the events.
      */
      aria.Utils.IgnoreUtilFocusChanges = false;

      aria.Utils.dialogOpenClass = 'has-dialog';

      /**
       * @desc Set focus on descendant nodes until the first focusable element is
       *       found.
       * @param element
       *          DOM node for which to find the first focusable descendant.
       * @returns
       *  true if a focusable element is found and focus is set.
       */
      aria.Utils.focusFirstDescendant = function (element) {
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (aria.Utils.attemptFocus(child) ||
              aria.Utils.focusFirstDescendant(child)) {
            return true;
          }
        }
        return false;
      }; // end focusFirstDescendant

      /**
       * @desc Find the last descendant node that is focusable.
       * @param element
       *          DOM node for which to find the last focusable descendant.
       * @returns
       *  true if a focusable element is found and focus is set.
       */
      aria.Utils.focusLastDescendant = function (element) {
        for (var i = element.childNodes.length - 1; i >= 0; i--) {
          var child = element.childNodes[i];
          if (aria.Utils.attemptFocus(child) ||
              aria.Utils.focusLastDescendant(child)) {
            return true;
          }
        }
        return false;
      }; // end focusLastDescendant

      /**
       * @desc Set Attempt to set focus on the current node.
       * @param element
       *          The node to attempt to focus on.
       * @returns
       *  true if element is focused.
       */
      aria.Utils.attemptFocus = function (element) {
        if (!aria.Utils.isFocusable(element)) {
          return false;
        }

        aria.Utils.IgnoreUtilFocusChanges = true;
        try {
          element.focus();
        }
        catch (e) {
        }
        aria.Utils.IgnoreUtilFocusChanges = false;
        return (document.activeElement === element);
      }; // end attemptFocus

      /* Modals can open modals. Keep track of them with this array. */
      aria.OpenDialogList = aria.OpenDialogList || new Array(0);

      /**
       * @returns the last opened dialog (the current dialog)
       */
      aria.getCurrentDialog = function () {
        if (aria.OpenDialogList && aria.OpenDialogList.length) {
          return aria.OpenDialogList[aria.OpenDialogList.length - 1];
        }
      };

      aria.closeCurrentDialog = function () {
        var currentDialog = aria.getCurrentDialog();
        if (currentDialog) {
          currentDialog.close();
          return true;
        }

        return false;
      };

      aria.handleEscape = function (event) {
        var key = event.which || event.keyCode;

        if (key === aria.KeyCode.ESC && aria.closeCurrentDialog()) {
          event.stopPropagation();
        }
      };

      document.addEventListener('keyup', aria.handleEscape);

      /**
       * @constructor
       * @desc Dialog object providing modal focus management.
       *
       * Assumptions: The element serving as the dialog container is present in the
       * DOM and hidden. The dialog container has role='dialog'.
       *
       * @param dialogId
       *          The ID of the element serving as the dialog container.
       * @param focusAfterClosed
       *          Either the DOM node or the ID of the DOM node to focus when the
       *          dialog closes.
       * @param focusFirst
       *          Optional parameter containing either the DOM node or the ID of the
       *          DOM node to focus when the dialog opens. If not specified, the
       *          first focusable element in the dialog will receive focus.
       */
      aria.Dialog = function (dialogId, focusAfterClosed, focusFirst) {
        this.dialogNode = document.getElementById(dialogId);
        if (this.dialogNode === null) {
          throw new Error('No element found with id="' + dialogId + '".');
        }

        var validRoles = ['dialog', 'alertdialog'];
        var isDialog = (this.dialogNode.getAttribute('role') || '')
          .trim()
          .split(/\s+/g)
          .some(function (token) {
            return validRoles.some(function (role) {
              return token === role;
            });
          });
        if (!isDialog) {
          throw new Error(
            'Dialog() requires a DOM element with ARIA role of dialog or alertdialog.');
        }

        // Wrap in an individual backdrop element if one doesn't exist
        // Native <dialog> elements use the ::backdrop pseudo-element, which
        // works similarly.
        var backdropClass = 'dialog-backdrop';
        if (this.dialogNode.parentNode.classList.contains(backdropClass)) {
          this.backdropNode = this.dialogNode.parentNode;
        }
        else {
          this.backdropNode = document.createElement('div');
          this.backdropNode.className = backdropClass;
          this.dialogNode.parentNode.insertBefore(this.backdropNode, this.dialogNode);
          this.backdropNode.appendChild(this.dialogNode);
        }
        this.backdropNode.classList.add('active');

        // Disable scroll on the body element
        document.body.classList.add(aria.Utils.dialogOpenClass);

        if (typeof focusAfterClosed === 'string') {
          this.focusAfterClosed = document.getElementById(focusAfterClosed);
        }
        else if (typeof focusAfterClosed === 'object') {
          this.focusAfterClosed = focusAfterClosed;
        }
        else {
          throw new Error(
            'the focusAfterClosed parameter is required for the aria.Dialog constructor.');
        }

        if (typeof focusFirst === 'string') {
          this.focusFirst = document.getElementById(focusFirst);
        }
        else if (typeof focusFirst === 'object') {
          this.focusFirst = focusFirst;
        }
        else {
          this.focusFirst = null;
        }

        // Bracket the dialog node with two invisible, focusable nodes.
        // While this dialog is open, we use these to make sure that focus never
        // leaves the document even if dialogNode is the first or last node.
        var preDiv = document.createElement('div');
        this.preNode = this.dialogNode.parentNode.insertBefore(preDiv,
          this.dialogNode);
        this.preNode.tabIndex = 0;
        var postDiv = document.createElement('div');
        this.postNode = this.dialogNode.parentNode.insertBefore(postDiv,
          this.dialogNode.nextSibling);
        this.postNode.tabIndex = 0;

        // If this modal is opening on top of one that is already open,
        // get rid of the document focus listener of the open dialog.
        if (aria.OpenDialogList.length > 0) {
          aria.getCurrentDialog().removeListeners();
        }

        this.addListeners();
        aria.OpenDialogList.push(this);
        this.clearDialog();
        this.dialogNode.className = 'default_dialog'; // make visible

        if (this.focusFirst) {
          this.focusFirst.focus();
        }
        else {
          aria.Utils.focusFirstDescendant(this.dialogNode);
        }

        this.lastFocus = document.activeElement;
      }; // end Dialog constructor

      aria.Dialog.prototype.clearDialog = function () {
        Array.prototype.map.call(
          this.dialogNode.querySelectorAll('input'),
          function (input) {
            input.value = '';
          }
        );
      };

      /**
       * @desc
       *  Hides the current top dialog,
       *  removes listeners of the top dialog,
       *  restore listeners of a parent dialog if one was open under the one that just closed,
       *  and sets focus on the element specified for focusAfterClosed.
       */
      aria.Dialog.prototype.close = function () {
        aria.OpenDialogList.pop();
        this.removeListeners();
        aria.Utils.remove(this.preNode);
        aria.Utils.remove(this.postNode);
        this.dialogNode.className = 'hidden';
        this.backdropNode.classList.remove('active');
        this.focusAfterClosed.focus();

        // If a dialog was open underneath this one, restore its listeners.
        if (aria.OpenDialogList.length > 0) {
          aria.getCurrentDialog().addListeners();
        }
        else {
          document.body.classList.remove(aria.Utils.dialogOpenClass);
        }
      }; // end close

      /**
       * @desc
       *  Hides the current dialog and replaces it with another.
       *
       * @param newDialogId
       *  ID of the dialog that will replace the currently open top dialog.
       * @param newFocusAfterClosed
       *  Optional ID or DOM node specifying where to place focus when the new dialog closes.
       *  If not specified, focus will be placed on the element specified by the dialog being replaced.
       * @param newFocusFirst
       *  Optional ID or DOM node specifying where to place focus in the new dialog when it opens.
       *  If not specified, the first focusable element will receive focus.
       */
      aria.Dialog.prototype.replace = function (newDialogId, newFocusAfterClosed,
        newFocusFirst) {
        var closedDialog = aria.getCurrentDialog();
        aria.OpenDialogList.pop();
        this.removeListeners();
        aria.Utils.remove(this.preNode);
        aria.Utils.remove(this.postNode);
        this.dialogNode.className = 'hidden';
        this.backdropNode.classList.remove('active');

        var focusAfterClosed = newFocusAfterClosed || this.focusAfterClosed;
        var dialog = new aria.Dialog(newDialogId, focusAfterClosed, newFocusFirst);
      }; // end replace

      aria.Dialog.prototype.addListeners = function () {
        document.addEventListener('focus', this.trapFocus, true);
      }; // end addListeners

      aria.Dialog.prototype.removeListeners = function () {
        document.removeEventListener('focus', this.trapFocus, true);
      }; // end removeListeners

      aria.Dialog.prototype.trapFocus = function (event) {
        if (aria.Utils.IgnoreUtilFocusChanges) {
          return;
        }
        var currentDialog = aria.getCurrentDialog();
        if (currentDialog.dialogNode.contains(event.target)) {
          currentDialog.lastFocus = event.target;
        }
        else {
          aria.Utils.focusFirstDescendant(currentDialog.dialogNode);
          if (currentDialog.lastFocus == document.activeElement) {
            aria.Utils.focusLastDescendant(currentDialog.dialogNode);
          }
          currentDialog.lastFocus = document.activeElement;
        }
      }; // end trapFocus

      window.openDialog = function (dialogId, focusAfterClosed, focusFirst) {
        var dialog = new aria.Dialog(dialogId, focusAfterClosed, focusFirst);
      };

      window.closeDialog = function (closeButton) {
        var topDialog = aria.getCurrentDialog();
        if (topDialog.dialogNode.contains(closeButton)) {
          topDialog.close();
        }
      }; // end closeDialog

      window.replaceDialog = function (newDialogId, newFocusAfterClosed,
        newFocusFirst) {
        var topDialog = aria.getCurrentDialog();
        if (topDialog.dialogNode.contains(document.activeElement)) {
          topDialog.replace(newDialogId, newFocusAfterClosed, newFocusFirst);
        }
      }; // end replaceDialog

    }());

  </script>
</html>
